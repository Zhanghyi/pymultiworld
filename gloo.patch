diff --git a/gloo/rendezvous/context.cc b/gloo/rendezvous/context.cc
index 9d6e3ca..24886a3 100644
--- a/gloo/rendezvous/context.cc
+++ b/gloo/rendezvous/context.cc
@@ -8,6 +8,7 @@
 
 #include "gloo/rendezvous/context.h"
 
+#include <iostream>
 #include <memory>
 
 #include "gloo/common/logging.h"
@@ -28,7 +29,9 @@ Context::~Context() {
 void Context::connectFullMesh(
     rendezvous::Store& store,
     std::shared_ptr<transport::Device>& dev) {
+  std::cout << ">>> connectFullMesh: address of store = " << std::addressof(store) << std::endl;
   auto transportContext = dev->createContext(rank, size);
+
   transportContext->setTimeout(getTimeout());
 
   transportContext->createAndConnectAllPairs(store);
diff --git a/gloo/rendezvous/prefix_store.cc b/gloo/rendezvous/prefix_store.cc
index 8065356..5d34fcf 100644
--- a/gloo/rendezvous/prefix_store.cc
+++ b/gloo/rendezvous/prefix_store.cc
@@ -9,6 +9,8 @@
 #include "prefix_store.h"
 
 #include <sstream>
+#include <iostream>
+#include <unistd.h>
 
 namespace gloo {
 namespace rendezvous {
@@ -16,16 +18,25 @@ namespace rendezvous {
 PrefixStore::PrefixStore(
     const std::string& prefix,
     Store& store)
-    : prefix_(prefix), store_(store) {}
+    : prefix_(prefix), store_(store) {
+  std::cout << getpid() << " >>> gloo::rendezvous:PrefixStore prefix_ = " << prefix_ << std::endl;
+  std::cout << getpid() << " >>> gloo::rendezvous:PrefixStore addr(store)= " << std::addressof(store) << std::endl;
+  std::cout << getpid() << " >>> gloo::rendezvous:PrefixStore addr(store_)= " << std::addressof(store_) << std::endl;
+}
 
 std::string PrefixStore::joinKey(const std::string& key) {
   std::stringstream ss;
-  ss << prefix_ << "/" << key;
+  std::cout << getpid() << " >>> gloo::rendezvous:PrefixStore::joinKey prefix_ = " << prefix_
+	    << " key = " << key << std::endl;
+  ss << prefix_ << "/" << key << std::endl;
   return ss.str();
 }
 
 void PrefixStore::set(const std::string& key, const std::vector<char>& data) {
   store_.set(joinKey(key), data);
+  std::cout << getpid() << " >>> gloo::rendezvous:PrefixStore::set addr(store_)= " << std::addressof(store_) << std::endl;
+  std::cout << getpid() << " >>> gloo::rendezvous:PrefixStore::set joinKey = " << joinKey(key)
+	    << " key = " << key << std::endl;
 }
 
 std::vector<char> PrefixStore::get(const std::string& key) {
diff --git a/gloo/transport/tcp/context.cc b/gloo/transport/tcp/context.cc
index f1445b2..da5ab03 100644
--- a/gloo/transport/tcp/context.cc
+++ b/gloo/transport/tcp/context.cc
@@ -8,6 +8,7 @@
 
 #include "gloo/transport/tcp/context.h"
 
+#include <iostream>
 #include <cstring>
 
 #include "gloo/common/error.h"
@@ -48,7 +49,6 @@ void Context::createAndConnectAllPairs(IStore &store) {
   int localRank = 0;
   bool localRankSet = false;
   auto localHostName = getHostname();
-
   // We will create all the pairs including self
   // the self pair will not be connected
   // it's just to keep the later seq num matching logic simple
@@ -58,7 +58,6 @@ void Context::createAndConnectAllPairs(IStore &store) {
     pairIdentifiers.emplace_back(
         static_cast<Pair*>(pair.get())->address().getSeq());
   }
-
   // Obtain the pair object for this rank
   // and tack on all the pair identifiers used for the remote side
   // to identify themselves use during the rendezvous process
@@ -75,7 +74,8 @@ void Context::createAndConnectAllPairs(IStore &store) {
   auto deviceAddress = Address(
       static_cast<const Pair*>(currentRankPair.get())->address().getSockaddr());
   Rank currentRankInfo(
-      localHostName, deviceAddress.bytes(), std::move(pairIdentifiers));
+		       localHostName, deviceAddress.bytes(), std::move(pairIdentifiers));
+  std::cout << ">>> createAndConnectAllPairs: rank " << rank << std::endl;
   store.set(std::to_string(rank), currentRankInfo.bytes());
 
   // Connect every pair
@@ -92,7 +92,9 @@ void Context::createAndConnectAllPairs(IStore &store) {
     // Wait for address of other side of this pair to become available
     std::ostringstream key;
     key << i;
+    std::cout << ">>> createAndConnectAllPairs: before wait " << i << std::endl;
     store.wait({key.str()}, getTimeout());
+    std::cout << ">>> createAndConnectAllPairs: after wait " << i << std::endl;
 
     // Connect to other side of this pair
     std::vector<char> rankInfoBytes = store.get(key.str());
@@ -108,7 +110,6 @@ void Context::createAndConnectAllPairs(IStore &store) {
         Address(remoteDeviceAddr, remoteRankInfo.pairIdentifiers[rank]);
     pair->connect(remoteAddr.bytes());
   }
-
   // Set the local rank info for all mesh pairs involving current rank
   for (int i = 0; i < size; i++) {
     if (i == rank) {
